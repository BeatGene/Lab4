# 文本编辑器项目架构文档

本文档旨在总结项目的核心架构设计理念，解释关键的重构决策，并帮助新加入的开发者理解系统的运作机制。

## 1. 核心设计理念

本项目采用了 **领域驱动设计 (DDD)** 的思想，结合 **命令模式 (Command Pattern)** 和 **事件驱动架构 (Event-Driven Architecture)**，构建了一个高内聚、低耦合、易于扩展的文本编辑器核心。

### 1.1 核心原则
*   **关注点分离 (SoC)**：UI 层只负责输入输出，不包含业务逻辑；应用层负责流程编排；领域层负责核心业务规则。
*   **对扩展开放，对修改关闭 (OCP)**：新增编辑器类型（如 XML 编辑器）或新命令时，无需修改现有的核心代码。
*   **依赖倒置 (DIP)**：高层模块不依赖低层模块，二者都依赖于抽象。

## 2. 架构演进与重构总结

在开发过程中，我们经历了一次重大的架构重构，从最初的“单一文本编辑器”演进为“支持多类型编辑器的通用平台”。

### 2.1 痛点与挑战
最初的设计中，`CommandExecutor` (UI层) 负责解析所有的命令参数（如 `insert 1:1 text`）。这导致了以下问题：
*   **耦合过重**：UI 层必须知道每种编辑器的具体命令格式。
*   **扩展困难**：如果要引入 XML 编辑器（使用 XPath 定位），必须修改 UI 层的解析逻辑，违反了 OCP。

### 2.2 解决方案：三层命令体系 (Three-Layer Command System)

为了解决上述问题，我们引入了 **三层命令体系**，实现了 **延迟解析 (Lazy Parsing)**。

1.  **第一层：UI 传输层 (Raw String)**
    *   用户输入被封装为 `EditorCommandRequest`。
    *   **特点**：不解析具体参数，只携带命令名称（如 `"insert"`）和原始参数字符串（如 `"1:1 hello"`）。
    *   **作用**：将原始意图无损传递给后端。

2.  **第二层：应用路由层 (Routing)**
    *   `CommandBus` 将请求分发给 `EditorCommandRequest.Handler`。
    *   `WorkspaceManager` 根据当前活动的编辑器（Active Editor），将请求路由给具体的 `IEditor` 实例。
    *   **作用**：解耦了“谁发出命令”和“谁执行命令”。

3.  **第三层：领域执行层 (Domain Execution)**
    *   具体的编辑器（如 `TextEditor`）实现 `resolveCommand(String name)` 方法。
    *   编辑器内部维护一个命令映射表 `Map<String, EditorCommand>`。
    *   **关键点**：参数解析逻辑被下沉到具体的命令实现中。`TextEditor` 知道如何解析 `"1:1"`，而未来的 `XmlEditor` 将知道如何解析 `XPath`。

下面举例说明该架构如何工作：

1. **UI 层：封装意图** (`CommandExecutor`)

用户在控制台输入 `insert 1:1 "hello"`。`CommandExecutor` 识别出这不是工作区命令（如 `load`、`save`），于是它不尝试解析参数，而是直接将其封装为一个通用的请求对象：

```java
case "insert" -> new EditorCommandRequest("insert", "1:1 \"hello\"");
```

关键点：UI 层完全不知道 `insert` 需要什么参数，它只是个传声筒。

2. **总线层：路由分发** (`CommandBus`)

`CommandBus` 收到 `EditorCommandRequest`，根据注册表找到对应的处理器：`EditorCommandRequest.Handler`。

3. **处理器层：动态查找** (`Handler`)

这是架构的枢纽。`Handler` 做三件事：

* 找人：问 `WorkspaceManager`："现在的活动编辑器是谁？"（假设活动编辑器是 `TextEditor`，返回了一个 `TextEditor` 实例）。
* 问路：调用 `editor.resolveCommand("insert")`。
* 执行：拿到具体的命令实现后，调用 `command.execute(doc, args)`。

4. **编辑器层：查表与执行** (`TextEditor`)

`TextEditor` 内部维护了一个 `Map<String, EditorCommand>`。
当 `resolveCommand("insert")` 被调用时，它从 `Map` 中取出对应的 Lambda 表达式或内部类实例。

5. **执行层：延迟解析** (`handleInsert`)

直到这一步，参数字符串 `"1:1 "hello""` 才被真正解析。
`handleInsert` 方法知道对于文本编辑器来说，参数格式应该是 `line:col text`。

**架构优势总结**

* **多态性** (Polymorphism)：如果当前是 `XmlEditor`，`resolveCommand("insert")` 会返回 XML 专属的插入逻辑（例如解析 `XPath`），而 UI 层和 `Handler` 层完全不需要修改。

* **延迟解析** (Lazy Parsing)：参数解析逻辑被推迟到了最后一刻（在具体编辑器内部），确保了解析规则与业务逻辑的强一致性。

* **开闭原则** (OCP)：新增 `xxxEditor` 只需实现 `IEditor` 并注册自己的 `Map`。不需要修改 `CommandExecutor` 或 `CommandBus`。

### 2.3 Document与Editor的职责划分

在新的架构中我们明确了对“文件”的抽象为 `Document` 类，它是一个充血模型，负责文件的物理存储和基本行操作。

对于一个文件被加载入内存/从内存保存到磁盘文件的功能，应当交给基础设施层的FileUtil处理，文件被加载到内存中成为`Document`，这是我们设计的基础。

`Document` 与文件是一对一的关系，其唯一id是文件路径。作为充血模型，其具有存储文件内容的内存空间 `List<String> lines`，以及对这些内容进行增删改查和操作这些内容的方法；

向上一层 ，是处理不同类型文件的editor。由于不同类型文件的“解释”方式不同，editor会定义具体操作，比如textEditor就是简单的按行插入删除，xmlEditor则会将文件当做树结构来处理，但到实际更改文件内容的时候，必须通过调用Document的方法实现，即无论上层如何解释一个文件的内容，最终都必须要将文件当成 `List<String>` 来操作。

在上述的设计理念下，Document是具有状态的，而editor是无状态的——它更像是“指令集翻译器”。

### 2.4 Document与Editor构成逻辑上的聚合

从 DDD 的视角来看，我们实际上构建了一个 **逻辑上的聚合**:

*   **状态 (State)**：`Document`。它持有数据（`List<String>`），代表了文件的物理形态。
*   **行为 (Behavior)**：`IEditor` (及其实现 `TextEditor`/`XmlEditor`)。它持有逻辑，代表了文件的业务语义。

**Document + IEditor 共同组成了一个完整的“聚合”**。
*   如果没有 `Document`，`Editor` 只是一个没有记忆的空壳处理器。
*   如果没有 `Editor`，`Document` 只是一堆没有意义的字符列表。

只有两者结合，才构成了一个可以被“编辑”、被“保存”、被“理解”的完整业务对象。

在标准的 DDD 教程中，聚合通常被演示为一个单一的类，比如 Order。而在演示“订单”这个领域时，领域中也只放了一个聚合：Order。

但在复杂的业务场景中，一个领域中可能包括多个聚合，而聚合也可能由于业务需求具有复杂的结构——就像本项目对于“文件”这一聚合的设计，就不是简单的一个Document类。

**为什么对Document和Editor进行了分离？**

通常 DDD 提倡将行为写在实体里（充血模型）。但由于我们的业务需求是 **“同一份数据，多种解释”**（例如对于 `TextEditor` 数据是“行和列”，对于 `XmlEditor` 数据是“DOM 树”），我们被迫将**可变的行为**（Editor）从**稳定的状态**（Document）中剥离出来，以支持多态和扩展性。

如果使用 Python 或 JavaScript 等动态语言，我们可能不需要 `IEditor` 接口来随时切换Editor实现：在动态语言中，类的方法可以在运行时被随意替换，我们可以直接在运行时，根据文件后缀名，将 `Document` 对象的 `insert` 方法替换为 `xml_insert` 函数：

```python
class Document:
    def insert(self):
        print("我是普通文本插入")

doc = Document()
doc.insert() # 输出: 我是普通文本插入

# 定义一个新的函数
def xml_insert(self):
    print("我是 XML 树节点插入")

# 动态修改：直接把 Document 类的 insert 方法换掉
Document.insert = xml_insert

doc.insert() # 输出: 我是 XML 树节点插入
```

但Java 是静态强类型语言，类的结构（有哪些方法）在编译期就确定了，无法在运行时随意修改一个对象的方法逻辑。为了在静态语言中模拟这种“动态切换逻辑”的能力，我们使用了 **策略模式**。
*   **组合优于继承**: 我们不修改 `Document`，而是将可变的逻辑封装在独立的 `IEditor` 策略对象中。
*   **运行时切换**: 通过在运行时更换 `IEditor` 的具体实现（`TextEditor` vs `XmlEditor`），我们达到了与动态语言修改方法逻辑相同的效果。

### 2.5 领域的再设计：从文件聚合到工作区聚合

在之前的设计中，我们将“文件”作为一个聚合，将“工作区”作为一个聚合，两个聚合进行“协作”共同构成了工作区领域。

但在后续的设计中，我们发现“工作区”在管理着“文件”这一聚合，而且是通过直接持有对象引用的方式进行管理的。

因此，从聚合划分的原则出发，我们重新审视了“工作区”与“文件”之间的关系:

1. 两者的状态是否具有强一致性？
    * 是，工作区的状态直接依赖于它所管理的文件对象。文件的存在与否、是否已修改，都会直接影响工作区的状态。
2. 两者的生命周期是否绑定？
    * 是，文件对象的创建与销毁由工作区来管理。工作区关闭时，相关的文件对象也会被释放。
3. 对两者的修改是否都必须通过同一聚合根？
    * 是，所有对文件的操作都必须通过工作区来进行。
4. 两者是否能被独立访问或操作？
    * 否，文件对象不能脱离工作区单独存在，用户无法在不打开工作区的情况下操作文件。

基于以上分析，我们决定将“文件”聚合纳入“工作区”聚合之内，重新形成工作区聚合。

## 5. 总结

当前的架构已经为 Lab 2 的多编辑器需求做好了充分准备。通过将参数解析下放给具体编辑器，我们成功地隔离了变化。新增 `XmlEditor` 只需实现 `IEditor` 接口并注册到系统中，无需修改现有的 UI 或架构代码。
